#!/usr/bin/perl
#
# lang2kvt.pl - Converts langenscheidt *.voc to kvoctrain's *.kvtml
#            Does the following:
#		analyse general header
#		remove langenscheidt specific information
#		continously rewrite the first of three lines giving:
#		+ foreign word
#		+ translation
#		+ chapter
#		while guessing word type information for entries in:
#		+ German
#		+ English
#		+ French
#		+ Spanish
#		rewrite lesson names 
#		append tables for conjugation and articles in:
#		+ German
#		+ English
#		+ French
#		+ Spanish
#		+ Italian
#		+ Czechian
#
# Options:
#	voc 			- *.voc file
#
# Version 0.1 22/08/01 - Andreas Neuper
#	initial release
#
# Version 0.2 20/09/01 - Andreas Neuper
#	extensions:
#		language recognition added (derived from input filename)
#		added (guessed) type information for English and Spanish
#		modifying kde-config file to add language
#	corrections:
#		resolved difficulties (CR left) with Lesson information
#
# Version 0.3 22/09/01 - Andreas Neuper
#	extensions:
#		added (guessed) type information for French
#		Article and conjugation tables added for:
#		    French, English, Italian, and Czechian
#		added Verb recognition by local ending (95%)
#		some more language definition lines
#	corrections:
#		Spanish words ending with -mente are adverbs
#		Spanish pronomina in conjugation table completed
#		Adding a space between concatenated lines
#		empty articel and conj. definitions for other languages
#		avoid rc-file update while kvoctrain is running
#		some minor or less obvious corrections
#
# Version 0.4 22/09/01 - Andreas Neuper
#	extensions:
#		first version of automated internet download
#	corrections:
#		instead of "en" was "it" used for English articles
#
####################################################################
chomp($cwd = `pwd`);
#
# User configurable variables
#
$myopt		= "";		# options (not used yet)
#
# command-line option exist for:
#
$author		= "http://www.Vokabeln.de";	# oder: "Langenscheidt";
$outdir 	= $cwd;		 		# Where the output should go
$langdefault	= "en";		# My favorite is English
$trans		= "de";		# My favorite is Deutsch
$longlesson	= 0;		# as you like
$proxy		= "-p http://proxy:8080/";

#######################################################################
# No User configurable parameters below here
#######################################################################

require "flush.pl";
use Getopt::Long;
$/="\r\n";	# we work with dos files

#
# Initialise internal global variables
#
$rcfile		= "$ENV{HOME}/.kde/share/config/kvoctrainrc" ;
$vocfile 	= "";		# Passed from command line
$kvtfile 	= "";		# adopt to command line
$lang		= "";		# initially unset
$filestage	= 0;		# file stage
%VOCLANG	= (	"GB",	"en",
			"US",	"en",
			"NL",	"nl",
#			"PL",	"pl",	# Polish
#			"TR",	"tr",	# Turkey
#			"SK",	"sk",	# Slovakian
#			"RO",	"ru",	# Rumanian
#			"GR",	"el",	# Greek
#			"IL",	"he",	# Hebraic
#			"J",	"ja",	# Japanese
			"DK",	"da",
			"CZ",	"cs",
			"H",	"hu",
			"FIN",	"fi",
			"IS",	"is",
			"F",	"fr",
			"I",	"it",
			"I-Lom",	"it",
			"D",	"de",
			"A",	"at",
			"CH",	"ch",
			"D",	"de",
			"E",	"es",
			"P",	"pt",
			"S",	"sv",
			"N",	"no",
			"Esp",	"us_eu",	# Esperanto
			"D-Fr",	"de",		# Fränkisch
			"D-Platt",	"pd",	# Plattdeutsch
			"D-Hes",	"hs",	# Hessisch
			"D-Schw",	"sw",	# Schwäbisch
			"D-Bay",	"by",	# Schwäbisch
			"GB-Alt",	"en",	# Shakespear
			"GB-Sco",	"sc",	# Scottish
			"",	"en"	);

####################################################
####################################################

# Get the parameters from the command line
if ( ! &GetOptions(
		"lang=s" => \$lang,
		"trans=s" => \$trans,
		"proxy=s" => \$proxy,
		"author=s" => \$author,
		"outdir=s" => \$outdir,
		"country=s" => \$country,
		"longlesson" => \$longlesson) ) {
   print "Usage:\tlang2kvt.pl [--lang=xx] [--trans=xx] [--autor=<name>]\n";
   print "\t\t [--longsession] [--outdir=<dir>] { --country=x | vocfile }\n";
   exit 1;
}

# Get input file name if it has been given
if ($ARGV[0] eq '' &&  $country eq "") {
    print STDERR "Error: no input filename.\n";
    print STDERR "Note: Trying to take --country=GB Samples from the internet.\n";
    $country="GB";
}

# All logging information goes into this file
$logfile = "/tmp/lang2kvt.log";
open(LOG, ">$logfile") || die "Cannot create $logfile: $!";

&printflush(STDOUT,"Waiting for generating files ...\n");
$tmp1=$#ARGV+1;
&printflush(STDOUT,"... $tmp1 files given via command line ...\n");

if ( $country ne "" ) {
    &printflush(STDOUT,"... fetching http://www.vokabeln.de/files/Voc-$country.zip ...\n");
    &printflush(STDOUT,"... using proxy service $proxy ...\n");
    `lwp-request $proxy http://www.vokabeln.de/files/Voc-$country.zip >/tmp/Voc-$country.zip`;
    # unzip -u update only!
    # unzip -o overwrite!
    `unzip -u /tmp/Voc-$country.zip >/tmp/unzip.log`;
    &printflush(STDOUT,"... updating Voc-$country.zip ...\n");
    $/="\n";	# we work with a unix file
    open(ZIP,"</tmp/unzip.log");
    while(<ZIP>) {
	chomp;
	if( /voc/ ) {
	    @tmp = split(/:/);
            $tmp[1] =~ s/ //g;
	    @res=(@res,$tmp[1]);
	}
    }
    close(ZIP);
    unlink("/tmp/unzip.log");
    $/="\r\n";	# we work with a dos file
}

for my $file (@res, @ARGV) {
    $vocfile = $file;
    &printflush(LOG,"... generating \"$kvtfile\"...\n");
    $lang		= "";		# initially unset
    $filestage	= 0;		# file stage
    &process_vocfile($vocfile);
}
print STDERR "...\tAll Complete.\n";
&printflush(LOG,"\nAll Complete.\n");
close(LOG);

exit;




sub process_vocfile() {
  &printflush(STDERR,"Converting $vocfile\t ...");
  $kvtfile = $outdir."/".substr($vocfile, 0, rindex($vocfile, ".")).".kvtml";
  $voclang = substr($vocfile, 0, index($vocfile, "_"));
  if("$lang" eq "") {		# overwrite automatic by commandline
    if("$voclang" ne "") {	# a valid lanugage selection was found
      $lang = $VOCLANG{$voclang};
    } else {			# use default language
      print STDERR "WARNING: language guessed to be \"$langdefault\".\n";
      $lang = "$langdefault";
    }
  }
  $title = substr($vocfile, 0, rindex($vocfile, "."));
  &get_info();		# Extract Information
  if("$lang" eq "") {		# overwrite automatic by commandline
    print STDERR "WARNING: language completely unsupported... but trying...\n";
  } else {
    &add2rcfile();		# add language info to rcfile
  }
  print STDERR "\"$kvtfile\" generated.\n";
}

#_____________________________________________________________________________
#_____________________________________________________________________________>
#_____________________________________________________________________________>
#

#
#	This subroutine works as a state machine
#	which increments state after each section:
#	 - 1 -  general header containing:
#	   -   		Title
#	   -   		Language Name
#	 - 2 -  langenscheidt specific information (removed)
#	 - 3 -	Vocabulary in the first of 3 line blocks containing:
#	   -		foreign word
#	   -		translation
#	   -		lesson
#	 - 4 -	lesson names 
#	 - 5 -	sub for articles
#	 - 6 -	sub for conjugation
#	All the named information is retrieved.
#
sub get_info {

  local $recnum = 0;
  local $privateline = 0;
  $/="\r\n";	# we work with dos files
  
  # Open input file
  open(VOC,  "$vocfile") || die "Cannot open $vocfile: $!"; 

  # Generate output file
  open(KVT, ">$kvtfile") || die "Cannot create $kvtfile: $!";
  print KVT '<?xml version="1.0"?>'."\n".'<!doctype kvtml system "kvoctrain.dtd">'."\n\n";
  
  while (<VOC>) {
  
    chomp; chomp;
    # chop twice since it is a dos file
   
    $recnum++ ;
    if (/^([^"]*"[^"]*"[^"]*)*"[^"]*$/) {
	$_ .= " ".<VOC>;
	redo;
    }
    $entrynum++ ;

    if ($privateline ne 0) {
	$privateline--;
	next;
    }
    if ($entrynum eq 1) {
        ($tmp1,$title,$tmp2) = split("\"");
    }
    if ($entrynum eq 4) {
        ($tmp1,$tlang,$tmp2,$ttrans) = split("\"");
    }
    if (/^.[sS]tandard.,. ./) {
        $filestage = 1;
	print KVT '<kvtml generator="lang2kvt v0.4.0"'."\n";
	print KVT 'title="'."$title".'" author="'."$author".'">'."\n\n";
	# print "$tlang $ttrans\n";
    }
    if ($filestage eq 0) {
	next;
    }
    if ($filestage eq 1) {
	if (/^[^,]*,[^,]*$/) {
	    $privateline=15;	# lines to follow (16 in total)
	    next;
	}
	$filestage = 2;
    }
    if ($filestage eq 2) {
        ($foreign,$local,$lesson) = split(/\",\"?/) ;
	$foreign=substr($foreign,1);
	if (length($foreign) eq 0) {
	    $filestage = 3;
	    print KVT '<lesson width="200">';
	    next;
	} else {
	    ;
	    print KVT "<e m=\"$lesson\"".&type_specific().">\t<o l=\"$lang\">$foreign</o>\t<t l=\"$trans\">$local</t>\t</e>\n";
	}
	$privateline = 2;	# lines to follow
    }
    if ($filestage eq 3) {
	($tmp1,$fullname,$tmp2) = split("\"");
        ($name,$lesson) = split(/\\/,$fullname);
        ($tmp1,$lesson) = split(/[ "]/,$lesson);
	if (length($lesson) ne 0) {
	    print KVT "\n\t".'<desc no="'."$lesson".'">';
	    if ($longlesson eq 0) {
		print KVT sprintf("%s %03d</desc>", $name, $lesson);
	    } else {
		print KVT "$fullname</desc>";
	    }
	}
	$privateline = 1;	# lines to follow
    }
  }
  print KVT "\n\t</lesson>\n\n";
  &add_article();
  &add_conjugation();
  print KVT "</kvtml>\n\n";

  close VOC;
  close KVT;
}

sub add_article() {
  print KVT "<options>\n\t<sort on=".'"1"'."/>\n\t</options>\n\n<article>\n";
  if ( $lang eq "es" ) {
    print KVT "\t<e l=\"es\">\t<fd>la</fd> <md>el</md> <nd>el</nd>\n";
    print KVT "\t\t\t<fi>una</fi> <mi>uno</mi> <ni>un</ni> </e>\n";
  } elsif ($lang eq "fr" ) {
    print KVT "\t<e l=\"fr\">\t<fd>la</fd> <md>le</md> \n";
    print KVT "\t\t\t<fi>un</fi> <mi>une</mi> </e>\n";
  } elsif ($lang eq "en" ) {
    print KVT "\t<e l=\"en\">\t<fd>the</fd> <md>the</md> <nd>the</nd>\n";
    print KVT "\t\t\t<fi>a</fi> <mi>a</mi> <ni>a</ni> </e>\n";
  } elsif ($lang eq "it" ) {
    print KVT "\t<e l=\"it\">\t<fd>la</fd> <md>il</md> <nd>il</nd>\n";
    print KVT "\t\t\t<fi>una</fi> <mi>un</mi> <ni>un</ni> </e>\n";
  } elsif ($lang eq "cz" ) {
    print KVT "\t<e l=\"cz\"> </e>\n";	# only the noun is modified
  } else {
    print KVT "\t<e l=\"$lang\"> </e>\n";
  } # and alays add the German definitions
  print KVT "\t<e l=\"de\">\t<fd>die</fd> <md>der</md> <nd>das</nd>\n";
  print KVT "\t\t\t<fi>eine</fi> <mi>ein</mi> <ni>ein</ni> </e>\n";
  print KVT "</article>\n\n";
}

sub add_conjugation() {
  print KVT "<conjugation>\n";
  if ( $lang eq "es" ) {
    print KVT "\t<e l=\"es\"> <s1>yo</s1> <s2>tu</s2>\n";
    print KVT "\t\t<s3m>el</s3m> <s3f>ella</s3f> <s3n>usted</s3n>\n";
    print KVT "\t\t<p1>nosotros</p1> <p2>vosotros</p2> <p3n>ustedes</p3n>\n";
    print KVT "\t\t<p3m>ellos</p3m> <p3f>ellas</p3f> </e>\n";
  } elsif ($lang eq "fr" ) {
    print KVT "\t<e l=\"fr\"> <s1>je</s1> <s2>tu</s2>\n";
    print KVT "\t\t<s3m>il</s3m> <s3f>elle</s3f>\n";
    print KVT "\t\t<p1>nous</p1> <p2>vous</p2>\n";
    print KVT "\t\t<p3m>ils</p3m> <p3f>elles</p3f> </e>\n";
  } elsif ($lang eq "en" ) {
    print KVT "\t<e l=\"en\"> <s1>I</s1> <s2>you</s2>\n";
    print KVT "\t\t<s3m>he</s3m> <s3f>she</s3f>\n";
    print KVT "\t\t<p1>we</p1> <p2>you</p2>\n";
    print KVT "\t\t<p3f common=\"1\">them</p3f> </e>\n";
  } elsif ($lang eq "it" ) {
    print KVT "\t<e l=\"it\"> <s1>io</s1> <s2>tu</s2>\n";
    print KVT "\t\t<s3m>egli</s3m> <s3f>ella</s3f> <s3n>esso</s3n>\n";
    print KVT "\t\t<p1>noi</p1> <p2>voi</p2>\n";
    print KVT "\t\t<p3f common=\"1\">essi</p3f> </e>\n";
  } elsif ($lang eq "cz" ) {
    print KVT "\t<e l=\"cz\"> <s1>já</s1> <s2>ty</s2>\n";
    print KVT "\t\t<s3m>on</s3m> <s3f>ona</s3f> <s3n>ono</s3n>\n";
    print KVT "\t\t<p1>my</p1> <p2>vy</p2>\n";
    print KVT "\t\t<p3m>oni</p3m> <p3f>ony</p3f> <p3f>ona</p3f> </e>\n";
  } else {
    print KVT "\t<e l=\"$lang\"> </e>\n";
  }
  print KVT "\t<e l=\"de\"> <s1>ich</s1> <s2>du</s2>\n";
  print KVT "\t\t<s3m>er</s3m> <s3f>sie</s3f> <s3n>es</s3n>\n";
  print KVT "\t\t<p1>wir</p1> <p2>ihr</p2> <p3f common=\"1\">sie</p3f> </e>\n";
  print KVT "</conjugation>\n";
}

#
#	This subroutine compares all entries one by one
#	- There is a initial section comparing the local
#	  translation (assuming it to be German).
#	- There are foreign sections for the languages
#		English
#		French
#		Spanish
#	None of the rules here claims to be perfect, but
#	there should be much less "false indications" than
#	correct type selections.
#
#
sub type_specific() {
  if( $local =~ /^eins$/
  ||  $local =~ /^zwei$/
  ||  $local =~ /^drei$/
  ||  $local =~ /^vier$/
  ||  $local =~ /^fünf$/
  ||  $local =~ /^sechs$/
  ||  $local =~ /^sieben$/
  ||  $local =~ /^acht$/
  ||  $local =~ /^neun$/
  ||  $local =~ /^zehn$/
  ||  $local =~ /^elf$/
  ||  $local =~ /^zwölf$/
  ||  $local =~ /^dreizehn$/
  ||  $local =~ /^vierzehn$/
  ||  $local =~ /^fünfzehn$/
  ||  $local =~ /^sechzehn$/
  ||  $local =~ /^siebzehn$/
  ||  $local =~ /^achtzehn$/
  ||  $local =~ /^neunzehn$/
  ||  $local =~ /^zwanzig$/
  ||  $local =~ /^dreißig$/
  ||  $local =~ /^vierzig$/
  ||  $local =~ /^fünfzig$/
  ||  $local =~ /^sechzig$/
  ||  $local =~ /^siebzig$/
  ||  $local =~ /^achtzig$/
  ||  $local =~ /^neunzig$/
  ||  $local =~ /^hundert$/
  ||  $local =~ /^einhundert$/
  ||  $local =~ /^zweihundert$/
  ||  $local =~ /^dreihundert$/
  ||  $local =~ /^vierhundert$/
  ||  $local =~ /^fünfhundert$/
  ||  $local =~ /^sechshundert$/
  ||  $local =~ /^siebenhundert$/
  ||  $local =~ /^achthundert$/
  ||  $local =~ /^neunhundert$/
  ||  $local =~ /^tausend$/){
      $type=" t=\"num:crd\"";
  } elsif( $local =~ /weil([,;].*)?$/
  ||  $local =~ /^und([,;].*)?$/
  ||  $local =~ /\sund([,;].*)?$/
  ||  $local =~ /\soder([,;].*)?$/
  ||  $local =~ /\saber([,;].*)?$/
  ||  $local =~ /^oder([,;].*)?$/
  ||  $local =~ /^aber([,;].*)?$/
  ||  $local =~ /daß([,;].*)?$/
  ||  $local =~ /^als([,;].*)?$/
  ||  $local =~ /\sals([,;].*)?$/
  ||  $local =~ /als ob([,;].*)?$/
  ||  $local =~ /obwohl([,;].*)?$/
  ||  $local =~ /trotzdem([,;].*)?$/
  ||  $local =~ /dennoch([,;].*)?$/
  ||  $local =~ /indem([,;].*)?$/
  ||  $local =~ /darum([,;].*)?$/
  ||  $local =~ /wobei([,;].*)?$/
  ||  $local =~ /^doch([,;].*)?$/
  ||  $local =~ /\sdoch([,;].*)?$/
  ||  $local =~ /damit([,;].*)?$/
  ||  $local =~ /während([,;].*)?$/
  ||  $local =~ /^falls([,;].*)?$/
  ||  $local =~ /\sfalls([,;].*)?$/){
      $type=" t=\"con\"";
  } elsif( $local =~ /^zweite[rs]?$/
  ||  $local =~ /dritte[rs]?$/
  ||  $local =~ /vierte[rs]?$/
  ||  $local =~ /fünfte[rs]?$/
  ||  $local =~ /sechste[rs]?$/
  ||  $local =~ /siebente[rs]?$/
  ||  $local =~ /achte[rs]?$/
  ||  $local =~ /neunte[rs]?$/
  ||  $local =~ /zehnte[rs]?$/
  ||  $local =~ /elfte[rs]?$/
  ||  $local =~ /zwölfte[rs]?$/
  ||  $local =~ /zwanzigste[rs]?$/
  ||  $local =~ /hundertste[rs]?$/
  ||  $local =~ /tausendste[rs]?$/){
      $type=" t=\"num:ord\"";
  } elsif( $local =~ /\?$/){
      $type=" t=\"qu\"";
  } elsif( $local =~ /^[A-ZÄÜÖ].*[\.\?!]$/){
      $type=" t=\"ph\"";
  } elsif( $local =~ /^[A-ZÄÜÖ]/){
      $type=" t=\"n\"";
  } elsif( $local =~ /en$/){
      $type=" t=\"v\"";
  } else {
      # maybe some lines are left - that's OK
      $type="";
  } 
  #
  # Now for the language specific terms
  #
  if( $lang eq "en") {
    #
    # some VERY simple strategy to recognize the
    # type of the entry 
    # (known things first - least likely guesses last)
    #
    if( $foreign =~ s/^to\s+°?//){
        $type=" t=\"v\"";
    } elsif( $foreign =~ /ous$/){
        $type=" t=\"aj\"";
    } elsif( $foreign =~ /ble$/){
        $type=" t=\"aj\"";
    } elsif( $foreign =~ /less$/){
        $type=" t=\"aj\"";
    } elsif( $foreign =~ /ic$/){
        $type=" t=\"aj\"";
    } elsif( $foreign =~ /ive$/){
        $type=" t=\"aj\"";
    } elsif( $foreign =~ /ly$/){
        $type=" t=\"av\"";
    } elsif( $foreign =~ /nt$/){
        $type=" t=\"aj\"";
    }
  } elsif( $lang eq "fr") {
    #
    #	Not perfect but a starting point
    #
    if( $foreign =~ s/^la\s+°?([^(]*)(\s\(m\))?/\1/){
        $type=" t=\"n:f\"";
    } elsif( $foreign =~ s/^le\s+°?([^(]*)(\s\(f\))?/\1/){
        $type=" t=\"n:m\"";
    } elsif( $foreign =~ s/^les\s+°?([^(]*)(\s\(m\))?/\1/){
        $type=" t=\"n:m\"";
    } elsif( $foreign =~ s/^les\s+°?([^(]*)(\s\(f\))?/\1/){
        $type=" t=\"n:f\"";
    } elsif( $foreign =~ s/^l[´']°?([^(]*)\s\(f\)/\1/){
        $type=" t=\"n:f\"";
    } elsif( $foreign =~ s/^l[´']°?([^(]*)\s\(m\)/\1/){
        $type=" t=\"n:m\"";
    } elsif( $foreign =~ s/^l[´']°?//){
        $type=" t=\"n\"";
    } elsif( $foreign =~ s/^une°?([^(]*)(\s\(f\))?/\1/){
        $type=" t=\"n:f\"";
    } elsif( $foreign =~ s/^un°?([^(]*)(\s\(m\))?/\1/){
        $type=" t=\"n:m\"";
    }
  } elsif( $lang eq "es") {
    #
    # some VERY simple strategy to recognize the
    # type of the entry 
    # (known things first - least likely guesses last)
    #
    if( $foreign =~ /[iae]rse$/){
        $type=" t=\"v:rf\"";
    } elsif( $foreign =~ /[iae]r(\s.*)?$/){
        $type=" t=\"v\"";
    } elsif( $foreign =~ s/^las?\s+//){
        $type=" t=\"n:f\"";
    } elsif( $foreign =~ s/^los\s+//){
        $type=" t=\"n:m\"";
    } elsif( $foreign =~ s/^el\s+//){
        $type=" t=\"n:m\"";
    } elsif( $foreign =~ /mente$/){
        $type=" t=\"av\"";
    } elsif( $foreign =~ /ión$/){
        $type=" t=\"n:f\"";
    } elsif( $type =~ " t=\"n\"" && $foreign =~ /as?$/){
        $type=" t=\"n:f\"";
    } elsif( $type =~ " t=\"n\"" && $foreign =~ /os?$/){
        $type=" t=\"n:m\"";
    } 
  }
  return $type;
}

#
#	This subroutine rewrites the rc-file for kvoctrain
#	(only for the executing user) to add language information
#	to it.  [not perfect but for convenience]
#
#
sub add2rcfile() {
    $/="\n";	# we work with a unix file
    $rnfile = "$rcfile.new" ;
    chomp($running = `ps ax | grep kvoctrain | grep -v grep`);
    open(RC, "<$rcfile" ) || die "kvoctrainrc preferences file not open: $!";
    open(RCNEW, ">$rnfile" ) || die "kvoctrainrc replacement preferences file not open: $!";
    $replace=1;	# i.e. language is not known yet
    while (<RC>) {
	chomp;
	($vockey,$vocval) = split("=");
	if(/NumLangSet/) {
	    $counter=$vocval;
	    $vocval++;
	    print RCNEW "$vockey=$vocval\n";
	} elsif(/ShortId\d*=$lang/) {
	    print STDERR "\nLanguage \"$lang\" already configured.\n";
	    $replace=0;
	} elsif(/PasteOrder/) {
	    print RCNEW "$vockey=$vocval$lang,\n";
	} elsif(/RecentFiles/) {
	    print RCNEW "$vockey=$kvtfile,$vocval\n";
	} else {
	    print RCNEW "$_\n";
	}
    }
    close(RC);
    print RCNEW "LongId$counter=$tlang\nShortId$counter=$lang\nShort2Id$counter=$voclang\n";
    print RCNEW "Pixmap$counter=/opt/kde/share/apps/kcmlocale/pics/flag_$lang.gif\n";
    close(RCNEW);
    if ( $replace ) {
	if( "$running" ne "" ) {
	    print STDERR "\nWARNING: Please close kvoctrain and rerun this program.\n";
	    unlink $rnfile;
	    return;
	}
    	rename $rnfile, $rcfile;
    } else {
    	unlink $rnfile;
    }
    return;
}

#
#
#
#
#
